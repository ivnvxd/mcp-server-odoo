"""Schema sanitizer for n8n compatibility.

n8n has strict requirements for JSON Schemas and sometimes fails to parse
complex schemas generated by Pydantic (e.g., array types like ["string", "null"]
or anyOf/allOf combinations). This module provides functions to sanitize those schemas.
"""

from typing import Any, Dict


def sanitize_schema(schema: Dict[str, Any]) -> Dict[str, Any]:
    """Recursively sanitize a JSON Schema for n8n compatibility.

    Args:
        schema: The JSON Schema dictionary to sanitize.

    Returns:
        The sanitized JSON Schema dictionary.
    """
    if not isinstance(schema, dict):
        return schema

    sanitized = {}
    for key, value in schema.items():
        if isinstance(value, dict):
            # Recursively sanitize nested dictionaries
            sanitized[key] = sanitize_schema(value)
        elif isinstance(value, list):
            if key == "type":
                # Handle type arrays like ["string", "null"] -> "string"
                # Find the first valid type that isn't "null"
                valid_types = [t for t in value if t != "null"]
                if valid_types:
                    sanitized[key] = valid_types[0]
                else:
                    sanitized[key] = "string"  # Fallback
            else:
                # Recursively sanitize items in arrays (e.g., required lists, enum arrays)
                sanitized[key] = [
                    sanitize_schema(item) if isinstance(item, dict) else item for item in value
                ]
        else:
            sanitized[key] = value

    # Flatten anyOf / allOf
    if "anyOf" in sanitized:
        # Pydantic often uses anyOf for optional fields where one option is {'type': 'null'}
        # and the other is the actual type definition.
        options = sanitized.pop("anyOf")
        if isinstance(options, list) and len(options) > 0:
            # We try to find the first option that isn't a null type
            valid_options = [
                opt for opt in options if isinstance(opt, dict) and opt.get("type") != "null"
            ]
            if valid_options:
                # Merge the first valid option into the current schema
                # We prioritize properties from the valid option, but preserve existing ones
                base_option = sanitize_schema(valid_options[0])
                for k, v in base_option.items():
                    if k not in sanitized:
                        sanitized[k] = v
            else:
                sanitized["type"] = "string"

    if "allOf" in sanitized:
        # Similarly for allOf, we just take the first definition for simplicity
        options = sanitized.pop("allOf")
        if isinstance(options, list) and len(options) > 0:
            base_option = sanitize_schema(options[0])
            for k, v in base_option.items():
                if k not in sanitized:
                    sanitized[k] = v

    return sanitized


def apply_n8n_schema_sanitization(fastmcp_app: Any) -> None:
    """Apply sanitization to all registered tools in a FastMCP application.

    Args:
        fastmcp_app: The FastMCP application instance.
    """
    try:
        # Access the private tool manager to iterate over registered tools
        tool_manager = fastmcp_app._tool_manager
        for _tool_name, tool in tool_manager._tools.items():
            original_schema = tool.parameters
            sanitized_schema = sanitize_schema(original_schema)
            tool.parameters = sanitized_schema
    except Exception as e:
        import logging

        logger = logging.getLogger(__name__)
        logger.warning(f"Failed to apply n8n schema sanitization: {e}")
